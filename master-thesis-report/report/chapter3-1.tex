\chapter{Key Infrastructure}
This chapter will present the concept of \gls{PKI} and \gls{IBE}, as well as problems and possible solutions. 

\section{Public Key Infrastructure}

X.509 (i.e. \gls{PKI}). Issues: certificates --> distribution and revocation.

\section{Identity-Based Cryptography}\label{ibc}
\gls{IBE} was first proposed by Shamir~\cite{DBLP:conf/crypto/Shamir84} in 1984. 
The concept of \gls{IBE} builds upon every user having an \gls{ID} that is used as the public key. 
This \gls{ID} can be anything, i.e. email, phone number, \gls{SSN}, or a Name (~\autoref{name}).
This eliminates the need of certificates.
Shamir did propose a scheme for \gls{IBS}, but not a scheme for \gls{IBE}. 
The \gls{IBE} implementation remained unsolved until 2001, when Dan Boneh and Matthew K. Franklin proposed~\cite{DBLP:conf/crypto/BonehF01}.
However the scheme has only been shown to be secure with a random oracles model~\cite{DBLP:journals/iacr/Waters04}, hence less practical.


\gls{IBE} is based upon performing cryptography with a publicly know \gls{ID}.
Since the \gls{ID} can be practically anything it is highly applicable for \gls{NDN} where the \gls{ID} can be a Name (``/ndn/no/ntnu/haakon'').
Hence the Name becomes the public key. 

There is a \gls{TTP} in \gls{IBE} that is called \gls{PKG}.
The \gls{PKG}s task is to produce a private key that corresponds to a given ID and provide 

\begin{enumerate}\label{ibc-methods}
  \item \texttt{Setup()} generates a key pair, \gls{MPK} and \gls{MSK}. These keys are used by only the \gls{PKG} to extracting private keys, encryption and decryption.
  \item \texttt{Extract(MPK, MSK, ID)} generates a Private Key from a given ID. 
  \item \texttt{Encrypt(MPK, ID, message)} encrypts the message.
  \item \texttt{Decrypt(MPK, private key, cipher)} decrypts the cipher generated from the encryption.
  \item \texttt{Signing(MPK, private key, message)} signs a hash digest of the message (e.g. \gls{SHA1}).
  \item \texttt{Verify(MPK, ID, message, signature)} verifies the signature.
\end{enumerate}

\todo{figure of PKG and nodes}

Thoroughness of the name allocation \gls{NRS} 

Key Revocation in IBE ~\cite{DBLP:journals/iacr/BoldyrevaGK12} 

To encrypt a message with \gls{IBE}, the user encrypts a \gls{CEK} with the recipients \gls{IBE} public key.
Then the user encrypts the message with the \gls{CEK}~\cite[section 2.2.2]{rfc5408}

Some drawbacks related to \gls{IBE} are listed below:
\begin{enumerate}
	\item If \gls{PKG} is compromised. Adversary has private key to all nodes that used the compromised \gls{PKG}
	\item \gls{PKG} can read and write messages related to the node, because it has all private keys, i.e. \gls{MITM}.
	\item \gls{PKG} and the requesting node has to establish a secure channel. 
\end{enumerate}

\section{Identity-Based Cryptography - Secureness}

Boneh and Franklins \gls{IBE} scheme is only secure when using random oracles.
A random oracle is like a ``black box'' that outputs truly random numbers.
Typically random oracles are used when a hash function does not fulfill the mathematical requirements of a proof. 
A system is in the \textit{random oracle model} when the system is fully secure and every hash function is replaced by a random oracle.

In the \textit{standard model} hash functions are sufficient to achieve a fully secure proof.
Since true randomness can be hard for every device to create, we tend to wanting to make cryptographic schemes in the standard model.

Boneh and Boyen proposed a fully secure scheme in the standard model~\cite{DBLP:conf/crypto/BonehB04}.
However it is not efficient. 

First practical scheme was ~\cite{DBLP:journals/iacr/Waters04}.
But as David Naccache states in his paper~\cite{DBLP:journals/iacr/Naccache05}, Waters' scheme without random oracles introduces too large public parameters (164\gls{KB}!).
Naccache proves that he was able to construct a practical and fully secure scheme in the standard model based on the \gls{DBDH} assumption.
The scheme is a modification of Waters' scheme, but with public parameters of just a few \gls{KB} size.

Brent Waters created a fully secure \gls{IBE} system with short parameters under simple assumption in 2009~\cite{DBLP:conf/crypto/Waters09}.

To understand the mathematical assumptions for \gls{IBE}, the reader should take a look at~\cite[section 3]{DBLP:conf/crypto/BonehF01} for details about bilinear maps and~\gls{BDH}.

\section{Key Distribution}
Instead of in \gls{PKI} where each public key is signed by a certificate authority and the generated certificate is sent as a response in \gls{HTTPS} then validated by the the client, I want to make the certificate authority obsolete by distributing every \gls{ID} (public key) issued by the \gls{PKG}.
This can be done through an IDSync application built upon the application presented in~\autoref{file-sync}.
In~\autoref{fig:pkg_sync} we see that the \gls{PKG} multicasts the \gls{ID} list to all devices that have joined the domain.
Each device can verify the integrity and authenticity of the sync state Data and be sure that the \gls{ID} list surely originates from its own \gls{PKG}.
\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{pkg_sync.png}
  \caption{IDSync with tree devices and a PKG.}
  \label{fig:pkg_sync}
\end{figure}

\section{Key Revocation}
Few alternatives to revocation scheme in \gls{IBE}.
One suggestion is to allocate private keys with the public key combined with some sort of date, e.g. month-year or just year. 
In this alternative a user has to renew its private key each time the date changes, i.e. either the month or the year depending on the date format.
The problem with the revocation solution is that it is cumbersome for the \gls{PKG}.


Key revocation becomes obsolete with the IDSync distribution solution. 
