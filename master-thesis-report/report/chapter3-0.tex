\chapter{File Synchronization over Named Data Network}\label{chp3:application}
This chapter will present some of the work done in conjunction with this thesis. 
Explaining what the file synchronization application is built upon and its purpose over the \gls{NDN} network. 

\section{File Synchronization Module}\label{file-sync}
Since \gls{NDN} provides multicast in network layer as explained in~\autoref{fig:ndn-multicast}, we do not have to think of network load in the same way as in \gls{IP}.  
One of the benefits is that we can distribute lots of data, to many people. 
In our case, synchronization of file(s) to a large group of nodes. 
For example we want to be able to distribute a list of public keys to a large set of nodes that wants to have every public key up-to-date.
Lets say there is a list owner, e.g. a trusted third party. 
When the list of public keys gets updated, caused by for instance a key revocation or a key initialization, every node should immediately synchronize with this new list.
Now since \gls{NDN} is pull based (\autoref{chp2:sec:ndn_architecture}), there is no way for the list owner to send the list to everyone.
To achieve the goal of synchronization, the \gls{NDN}-team has developed an application over \gls{NDN}, ChronoSync.

\section{ChronoSync}\label{chronosync}
ChronoSync is a distributed (server-less) synchronization application developed by the \gls{NDN}-team. 
Each node in a ChronoSync application broadcasts its sync state in a Sync Interest (e.g. /ndn/sync/fileSyncFolder/<username>/<state>).
When a node receives a Sync Interest, it will inspect the state of the interest, and compare with its own state.
Each node holds a state tree that is used to detect new and outdated states.
If the incoming interests state is equal to the receiving node, the node has no reason to do anything, as the system is in a \textit{stable state}.
If not, the receiving node has to find out whether the incoming interest is 1) a state the node itself has been in, or if its 2) a new state.
In case of 1), the receiving node has new data and should provide the new content as a response to the incoming interest. In case of 2), the receiving node should send out a Recovery Interest for the new state.

\begin{enumerate}
  \item \textit{Sync Interest} is an interest a participating node sends out to discover new data.
  \item \textit{Sync Data} is a response to 1), if another participating node has new data.
  \item \textit{Recovery Interest} is an interest sent out if a node discovers that another node has a newer state.
  \item \textit{Recovery Data} is a response to 3).
\end{enumerate}

ChronoSync is only taking care of data discovery, and leaves other logic to the application. 
Such logic can be for instance; what should happen when a new participant enters the room.
Should all history be download?

As mentioned in~\autoref{name}, the \gls{NDN} protocol leaves the naming rules up to each application to decide.
ChronoSync have to forms of rules in this matter. 

ChronoSync is explained in detail here~\cite{DBLP:conf/icnp/ZhuA13}.

\section{File Watcher}
The application should trigger synchronization when files that are watched is changed, or when a file is added/removed.
A library that makes it possible to watch files in an \gls{OS} is Watchdog~\cite{watchdog}. 
